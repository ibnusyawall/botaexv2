const moment = require("moment-timezone")
const fs = require("fs")
const imageToBase64 = require('image-to-base64')
//const { spawnSync } = require('child_process')

const time = moment().tz('Asia/Jakarta').format("HH:mm:ss")

const
{
   ChatModification,
   WAConnection,
   MessageType,
   Presence,
   MessageOptions,
   Mimetype,
   WALocationMessage,
   WA_MESSAGE_STUB_TYPES,
   ReconnectMode,
   ProxyAgent,
   waChatKey,
   GroupSettingChange
} = require("@adiwajshing/baileys")

const { exec, spawnSync } = require("child_process")
const textPorn = require(process.cwd() + '/lib/textporn')
const Archy = require(process.cwd() + '/lib/menu/Archy')
const imgBB = require(process.cwd() + '/lib/menu/imgBB')

const copyright = '\n\n----    ----\n*Â©aex-bot copyright | science 2019-2020*'

prefix = '.'
/*block = []

client.on('CB:Blocklist', json => {
    if (block.length > 2) return
    for (let i of json[1].blocklist) {
        block.push(i.replace('c.us','s.whatsapp.net'))
    }
})*/

Array.prototype.sortBy = function(p) {
  return this.slice(0).sort(function(a,b) {
    return (a[p] > b[p]) ? 1 : (a[p] < b[p]) ? -1 : 0;
  });
}

const CUSTOMHANDLER = async (client, m) => {
    global.prefix
    //global.block

//    var block = []

    /*client.on('CB:Blocklist', json => {
        console.log(JSON.stringify(json, null, '\t'))
        if (block.length > 2) return
        for (let i of json[1].blocklist) {
            block.push(i.replace('c.us','s.whatsapp.net'))
        }
    })
    console.log(block)*/
    if (!m.message) return
    if (m.key && m.key.remoteJid == 'status@broadcast') return
    if (m.key.fromMe) return

    const content = JSON.stringify(m.message)
    const from = m.key.remoteJid
    const type = Object.keys(m.message)[0]
    const { text, extendedText, contact, location, liveLocation, image, video, sticker, document, audio, product } = MessageType

    body = (type === 'conversation' && m.message.conversation.startsWith(prefix)) ? m.message.conversation : (type == 'imageMessage') && m.message.imageMessage.caption.startsWith(prefix) ? m.message.imageMessage.caption : (type == 'videoMessage') && m.message.videoMessage.caption.startsWith(prefix) ? m.message.videoMessage.caption : (type == 'extendedTextMessage') && m.message.extendedTextMessage.text.startsWith(prefix) ? m.message.extendedTextMessage.text : ''
    budy = (type === 'conversation') ? m.message.conversation : (type === 'extendedTextMessage') ? m.message.extendedTextMessage.text : ''
    const argv = body.slice(1).trim().split(/ +/).shift().toLowerCase()
    const args = body.trim().split(/ +/).slice(1)
    const isCmd = body.startsWith(prefix)

    const nomorbot = client.user.jid
    const ownerNumber = ["6285892766102@s.whatsapp.net"] // replace this with your number
    const isGroup = from.endsWith('@g.us')
    const id = isGroup ? m.participant : m.key.remoteJid
    const owner = '6282299265151@s.whatsapp.net'
    const groupMetadata = isGroup ? await client.groupMetadata(from) : ''
    const groupName = isGroup ? groupMetadata.subject : ''
    const groupId = isGroup ? groupMetadata.jid : ''
    //const groupMembers = isGroup ? groupMetadata.participants : ''
    //const groupAdmins = isGroup ? getGroupAdmins(groupMembers) : ''
    //const isBotGroupAdmins = groupAdmins.includes(botNumber) || false
    //const isGroupAdmins = groupAdmins.includes(sender) || false
    //const isWelkom = isGroup ? welkom.includes(from) : false
    //const isNsfw = isGroup ? nsfw.includes(from) : false
    //const isSimi = isGroup ? samih.includes(from) : false
    //const isOwner = ownerNumber.includes(sender)
    const isMedia = (type === 'imageMessage' || type === 'videoMessage' || type === 'audioMessage')
    const isQuotedImage   = type === 'extendedTextMessage' && content.includes('imageMessage')
    const isQuotedVideo   = type === 'extendedTextMessage' && content.includes('videoMessage')
    const isQuotedAudio   = type === 'extendedTextMessage' && content.includes('audioMessage')
    const isQuotedSticker = type === 'extendedTextMessage' && content.includes('stickerMessage')
    const isQuotedMessage   = type === 'extendedTextMessage' && content.includes('conversation')

    const fromBot   = isQuotedMessage ? m.message.extendedTextMessage.contextInfo.participant : null
    const isFromBot = fromBot != null ? fromBot === nomorbot : false

    const client2 = {
        reply: function(f, t) {
            client.sendMessage(f, t, text, { quoted: m })
        },
        sendText: function(f, t) {
            client.sendMessage(f, t, text)
        },
        sendImage: function(f, i, c = null) {
            imageToBase64(i)
                .then(data => {
                     var buffer = fs.readFileSync(data, 'base64')
                     client.sendMessage(f, buffer, image, { quoted: m, caption: c })
                })
        },
        sendTts: function(f, l, t) {
            var tts = require('node-gtts')[l]
            tts.save(process.cwd() + '/tts.ogg', t, async () => {
                if (err) throw err
                var buffer = fs.readFileSync('./tts.ogg')
                await client.sendMessage(f, buffer, audio, { quoted: m, ptt: true })
            })
        },
        sendAudioAsPtt: function(f, a) {
            var options = {
                __ogg: 'audio.ogg'
            }
            exec(`ffmpeg -i ${a} -ar 48000 -vn -c:a libopus ${options.__ogg}`, (err) => {
                var buffer = fs.readFileSync('./' + options.__ogg)
                client.sendMessage(f, buffer, audio, { quoted: m, ptt: true })
            })
        },
        sendTextWithMentions: function(f, b) {
           var options = {
               text: b,
               contextInfo: { mentionedJid: b.match(/\d{1,3}?\d{1,10}\W/gi).join(' ').replace(/@/gi, '').split(' ').map(d => d + '@s.whatsapp.net') },
               quoted: m
           }
           client.sendMessage(f, options, text)
        },
        setGroupToAdminsOnly: function(f, s = true || false) {
            client.groupSettingChange(f, GroupSettingChange.messageSend, s)
        },
        setSubject: function(f, t) {
            client.groupUpdateSubject(f, t)
        },
        setDescription: function(f, t) {
            client.groupUpdateDescription(f, t)
        },
        promoteParticipant: function(f, p) {
            client.groupMakeAdmin(f, p)
        },
        demoteParticipant: function(f, p) {
            client.groupDemoteAdmin(f, p)
        },
        addParticipant: function(f, p = []) {
            client.grupAdd(f, p)
        },
        removeParticipant: function(f, p = []) {
            client.groupRemove(f, p)
        },
        getGroupInviteLink: function(f) {
            client.getGroupInviteLink(f)
        },
        setGroupProfilePicture: function(f, i) {
            var buffer = fs.readFileSync('./' + i)
            client.updateProfilePicture(f, buffer)
        },
        getProfilePicture: async function(f) {
            var profile = await client.getProfilePicture(f)
            return profile
        }
    }

    //const messageContent = m.message
    //const text = m.message.conversation
    //const messageType = Object.keys(messageContent)[0]
    //var nomor = m.participant
    //var owner = '6282299265151@s.whatsapp.net'

    //var bot = owner === nomor ? true : false

    //const re = /[\#\!\@\.]/

    //const value = text.split(' ').splice(1).join(' ')
    //const value2 = text.split(' ').splice(3).join(' ')

    //let id = m.key.remoteJid
    //let imageMessage = m.message.imageMessage

    //const prefix = messageType === 'imageMessage' ? imageMessage.caption.split(' ')[0].split(re)[1] : text.split(' ')[0].split(re)[1] // multiple prefix

    var isAdmin = async (where, idGroup) => {
        var group  = await client.groupMetadata(idGroup)
        var member = group['participants']
        var number = where.includes('s.whatsapp.net') ? where.replace(/s.whatsapp.net/, 'c.us') : where
        var isAdminGroup = member.filter(admin => admin.id === number)[0].isAdmin
        return isAdminGroup
    }

    var isBotAdmin = async (where, idGroup) => {
        var group  = await client.groupMetadata(idGroup)
        var member = group['participants']
        var number = where.includes('s.whatsapp.net') ? where.replace(/s.whatsapp.net/, 'c.us') : where
        var isAdminGroup = member.filter(admin => admin.id === number)[0].isAdmin
        return isAdminGroup
    }

    var logging = {
        isNotSticker: 'reply stiker dengan caption: .toimg',
        userIsNotAdmin: 'kamu bukan admin.',
        botIsNotAdmin: 'Jadikan aex sebagai admin untuk memaksimalkan fitur group!',
        isNotGroup: 'Command ini hanya berlaku didalam group saja.',
        isNotOwner: 'Command khusus owner bot!'
    }
//    console.log(`[ ${time} ] => Nomor: [ ${id.split("@s.whatsapp.net")[0]} ] => ${text}`);

    switch (argv) {

        case 'shell':
            if (id === owner) {
                exec(args.join(' '), (err, stdout) => {
                    if (err) client2.reply(from, err)
                    client2.reply(from, `root@localheart: ${process.cwd().replace('/data/data/com.termux/files/home/', '~/')} *Â»* ${args.join(' ')}\n${stdout}`)
                })
            } else {
                client2.reply(from, logging.isNotOwner)
            }
            client2.reply(from, 'is owner: ' + id===owner)
            break
        case 't':
            var options = {
                contextInfo: { forwardingScore: 1, isForwarded: true }
            }
            await client.sendMessage(id, args.join(' '), text, options)
            break
        case 'forward':
            switch (args[0]) {
                case 'tome':
                    //var m = await client.loadChats(id, 1)
                    //client2.reply(from, JSON.stringify(m, null, '\t'))
                    if (isQuotedMessage || isQuotedVideo || isQuotedImage || isQuotedAudio) {
                        var pel = (isQuotedMessage) ? m.message.extendedTextMessage.contextInfo.quotedMessage.conversation : (isMedia) ? JSON.parse(JSON.stringify(m).replace('quotedM','m')).message.extendedTextMessage.contextInfo : m

                        if (isQuotedMessage) {
                            var options = {
                                contextInfo: { forwardingScore: 1, isForwarded: true }
                            }
                            await client.sendMessage(id, pel, text, options)
                            client2.reply(from, `!isMedia: ${isQuotedMessage} [ ${JSON.stringify(Object.keys(m.extendedTextMessage.contextInfo.quotedMessage)[0]).replace(/\"|(Message)/gi, '')} ]\n`)
                        } else if (isQuotedImage || isQuotedVideo || isQuotedAudio) {
                            var options = {
                                contextInfo: { forwardingScore: 1, isForwarded: true }
                            }

                            var buffer = await client.downloadMediaMessage(pel)
                            var tipe = JSON.stringify(Object.keys(m.extendedTextMessage.contextInfo.quotedMessage)[0]).replace(/\"|(Message)/gi, '')

//                            await client.sendMessage(id, buffer, MessageType[tipe], options)
                            client2.reply(from, `${JSON.stringify(Object.keys(m.extendedTextMessage.contextInfo.quotedMessage)[0]).replace(/\"|(Message)/gi, '')}\n`)
                        }
//                        var cl = await client.loadMessage(from, m.message.extendedTextMessage.contextInfo.stanzaId)
//client2.reply(from, `${JSON.stringify(Object.keys(m.extendedTextMessage.contextInfo.quotedMessage)[0]).replace(/\"|(Message)/gi, '')}\n`)
//                        await client.forwardMessage(id, cl.key.id)
                    }
                    break
                default:
                    break
            }
            break
        case 'ret':
            if (isQuotedMessage) {
                var hh = args.join(' ')
                var cl = await client.loadMessage(from, m.message.extendedTextMessage.contextInfo.stanzaId)
                var mm = args.length > 0 ? `${JSON.parse( cl[String(hh)] )}` : cl
                /*switch (args[0]) {
                    case 
                }*/
                client2.reply(from, JSON.stringify(mm, null, '\t'))
            }
            break
        case 'list':
            switch(args[0]) {
                case 'group':
                    var chat   = await client.chats.all()
                    var cgroup = chat.filter(stat => stat.jid.endsWith('@g.us'))

                    var msg = `Total Group: ${cgroup.length}\n\n`
                    var ind = 1

                    cgroup.sortBy('count').map(({ count, name }) => {
                        msg += `*${ind++}*. ${name} [ ${count} chat ]\n`
                    })

                    client2.reply(from, msg)
                    break
                case 'chat':
                    var chat   = await client.chats.all()
                    var cchat  = chat.filter(stat => stat.jid.endsWith('@s.whatsapp.net'))

                    var msg = `Total Chat Pribadi: ${cchat.length}\n\n`
                    var ind = 1

                    cchat.map(({ count, jid }) => {
                        msg += `*${ind++}*. ${jid.split(/@/)[0]} [ ${count} chat ]\n`
                    })

                    client2.reply(from, msg)
                    break
                default:
                    break
            }
            break
        case 'leave':
            switch(args[0]) {
                case 'delay':
                    var admin = await isAdmin(id, from)

                    if (!admin) return client2.reply(from, logging.userIsNotAdmin)
                    if (!isGroup) return client2.reply(from, logging.isNotGroup)

                    await client2.reply(from, `aex akan keluar group dalam hitungan: *${args.join(' ')}* detik dari sekarang....`)

                    setTimeout( async () => {
                        await client.groupLeave(from)
                    }, Number(`${args.splice(1).join(' ')}000`))
                break
                case 'all':
                    var isowner = id === owner

                    if (!owner) return client2.reply(from, logging.isNotOwner)

                    var chat   = await client.chats.all()
                    var cgroup = chat.filter(stat => stat.jid.endsWith('@g.us'))

                    var msg = `aex bot sedang melakukan uji coba *leave all group* , invite kembali aex jika dibutuhkan, bye ðŸ‘‹ðŸ»\n\n*https://chat.whatsapp.com/HtrGfYgAz9iFxUaowKo2tf*`

                    // cgroup.map(({ jid, count, name }) => {
                    //     client2.reply(jid, `halo *${name}*!\n\n${msg}`)
                    //
                    //     setTimeout( async () => {
                    //         await client.groupLeave(jid)
                    //     }, Number(`${args.splice(1).join(' ')}000`))
                    // })

                    var ids = []

                    cgroup.map(({ jid }) => {
                        ids.push(jid)
                    })

                    var loop = (i) => {
                        if (ids[i]) {
                             client2.reply(ids[i], `halo *${name}*!\n\n${msg}`)

                             setTimeout( async () => {
                                  await client.groupLeave(jid)
                             }, Number(`${args.splice(1).join(' ')}000`))
                             setTimeout(() => {
                                  loop(i + 1)
                             }, 4000)
                        }
                    }
                    loop(0)
                    // client2.reply(from, msg)
                break
                default:
                    var admin = await isAdmin(id, from)

                    if (!admin) return client2.reply(from, logging.userIsNotAdmin)
                    if (!isGroup) return client2.reply(from, logging.isNotGroup)

                    await client.groupLeave(from)
                break
            }
            break
        case 'owner':
            var vcard2 = "BEGIN:VCARD\nVERSION:3.0\nN:;Ibnusyawall;;;\nFN:Ibnusyawall\nORG:OWNER AEXBOT\nTITLE:\nitem1.TEL;waid=6282299265151:+62 822-9926-5151\nitem1.X-ABLabel:Ponsel\nX-WA-BIZ-NAME:Ibnusyawall\nEND:VCARD"
            var vcard = 'BEGIN:VCARD\n' // metadata of the contact card
                      + 'VERSION:3.0\n' 
                      + 'FN:Ibnusyawall\n' // full name
                      + 'ORG:OWNER AEXBOT;\n' // the organization of the contact
                      + 'item1.TEL;type=CELL;type=VOICE;waid=6282299265151:+62 822-9926-5151\n' // WhatsApp ID + phone number
                      + 'item1.X-ABLabel:Ponsel\n'
                      + 'X-WA-BIZ-NAME:Ibnusyawall\n'
                      + 'END:VCARD'
            var kirim = await client.sendMessage(from, { displayName: 'Ibnusyawall', vcard: vcard, quoted: m }, contact)
            await client.sendMessage(from, 'untuk bantuan lebih lanjut atau sekedar ingin berteman bisa chat kontak tsb yah kak^^.', text, { quoted: kirim })
            break
        case 'simulate':
            switch (args[0]) {
                case 'typing':
                    await client.updatePresence(from, Presence.composing)
                    break
                case 'recording':
                    await client.updatePresence(from, Presence.recording)
                    break
                case 'stop':
                    await client.updatePresence(from, Presence.paused)
                    break
                default:
                    break
            }
            break
        case 'del':
            var admin     = await isAdmin(id, from)

            if (!admin) return client2.reply(from, logging.userIsNotAdmin)

            if ((id === owner || admin) && isFromBot) {
                await client.deleteMessage(from, { id: m.message.extendedTextMessage.contextInfo.stanzaId, remoteJid: from, fromMe: true })
            } else if (!isGroup && isFromBot) {
                //
            }
            break
        case 'fitnah':
            // case fitnah by aex-bot # don't delete this comment!!
            var split = args.join(' ').replace(/@|\d/gi, '').split('|')
            var taged = m.message.extendedTextMessage.contextInfo.mentionedJid[0]
            //client2.sendText(from, `${split}\n\n${taged}`)
            var options = {
                contextInfo: {
                    participant: taged,
                    quotedMessage: {
                        extendedTextMessage: {
                            text: split[0]
                        }
                    }
                }
            }
            //client2.reply(from, JSON.stringify(options, null, '\t'))
            client.sendMessage(from, `${split[1]}`, MessageType.text, options)
            break
        case 'exec':
            switch(args[0]) {
                case 'js':
                    var withOption = isQuotedMessage ? m.message.extendedTextMessage.contextInfo.quotedMessage.conversation.replace(/\n/gi, ';') : args.splice(1).join(' ').replace(/\n/gi, ';')
                    var data = spawnSync('node', ['-e', withOption]).stdout.toString('utf-8')
                    client2.reply(from, `*CODE EXECUTER*: NODEJS\n\nOUTPUT:\n\n\`\`\`${data}\`\`\`${copyright}`)
                    break
                default:
//                    client2.reply(from, `quoted: ${isQuotedMessage}\n\n${isQuotedMessage ? m.message.extendedTextMessage.contextInfo.quotedMessage.conversation : args.splice(1).join(' ')}`)
                    break
            }
            break
        case 'gclink':
            if (!isGroup) return client2.reply(from, logging.isNotGroup)

            var botAdmin  = await isBotAdmin(nomorbot, from)
            if (!botAdmin) return client2.reply(from, logging.botIsNotAdmin)

            var link = await client.groupInviteCode(from)
            var isLinkGC = `Link ðŸ‘‰ðŸ»: *https://chat.whatsapp.com/${link}*`
            client2.reply(from, `Link Group: *${groupMetadata.subject}*\n\n${isLinkGC}`)
            break
        case 'setgc':
            switch (args[0]) {
               case 'promote':
                   var admin     = await isAdmin(id, from)
                   var botAdmin  = await isBotAdmin(nomorbot, from)

                   if (!isGroup) return client2.reply(from, logging.isNotGroup)
                   if (!botAdmin) return client2.reply(from, logging.botIsNotAdmin)
                   if (!admin) return client2.reply(from, logging.userIsNotAdmin)

                   var taged = m.message.extendedTextMessage.contextInfo.mentionedJid[0]

                   var options = {
                       text: `@${taged.split("@s.whatsapp.net")[0]} kamu sekarang adalah admin!`,
                       contextInfo: { mentionedJid: [taged] }
                   }

                   client.sendMessage(from, options, MessageType.text)

                   client.groupMakeAdmin(from, [taged])
                   break
               case 'demote':
                   var admin     = await isAdmin(id, from)
                   var botAdmin  = await isBotAdmin(nomorbot, from)

                   if (!isGroup) return client2.reply(from, logging.isNotGroup)
                   if (!botAdmin) return client2.reply(from, logging.botIsNotAdmin)
                   if (!admin) return client2.reply(from, logging.userIsNotAdmin)

                   var taged = m.message.extendedTextMessage.contextInfo.mentionedJid[0]

                   var options = {
                       text: `@${taged.split("@s.whatsapp.net")[0]} kamu sekarang bukan admin!`,
                       contextInfo: { mentionedJid: [taged] }
                   }

                   client.sendMessage(from, options, MessageType.text)

                   client2.demoteParticipant(from, [taged])
                   break
               case 'name':
                   var admin     = await isAdmin(id, from)
                   var botAdmin  = await isBotAdmin(nomorbot, from)
                   //var nonOption = im
                   if (!isGroup) return client2.reply(from, logging.isNotGroup)
                   if (!botAdmin) return client2.reply(from, logging.botIsNotAdmin)
                   if (!admin) return client2.reply(from, logging.userIsNotAdmin)

                   client2.setSubject(from, args.splice(1).join(' '))
                   break
               case 'desc':
                   var admin     = await isAdmin(id, from)
                   var botAdmin  = await isBotAdmin(nomorbot, from)
                   //var nonOption = im
                   if (!isGroup) return client2.reply(from, logging.isNotGroup)
                   if (!botAdmin) return client2.reply(from, logging.botIsNotAdmin)
                   if (!admin) return client2.reply(from, logging.userIsNotAdmin)

                   client2.setDescription(from, args.splice(1).join(' '))
                   break
               case 'pp':
                   var admin     = await isAdmin(id, from)
                   var botAdmin  = await isBotAdmin(nomorbot, from)
                   var encmedia  = isQuotedImage ? JSON.parse(JSON.stringify(m).replace('quotedM','m')).message.extendedTextMessage.contextInfo : m
                   var media = await client.downloadAndSaveMediaMessage(encmedia)

                   if (!isGroup) return client2.reply(from, logging.isNotGroup)
                   if (!botAdmin) return client2.reply(from, logging.botIsNotAdmin)
                   if (!admin) return client2.reply(from, logging.userIsNotAdmin)

                   client2.setGroupProfilePicture(from, media)
                   //client2.reply(from, pp)
                   break
               case 'open':
                   var admin     = await isAdmin(id, from)
                   var botAdmin  = await isBotAdmin(nomorbot, from)
                   //var nonOption = im
                   if (!isGroup) return client2.reply(from, logging.isNotGroup)
                   if (!botAdmin) return client2.reply(from, logging.botIsNotAdmin)
                   if (!admin) return client2.reply(from, logging.userIsNotAdmin)

                   client2.setGroupToAdminsOnly(from, false)
                   break
               case 'close':
                   var admin     = await isAdmin(id, from)
                   var botAdmin  = await isBotAdmin(nomorbot, from)
                   //var nonOption = im
                   if (!isGroup) return client2.reply(from, logging.isNotGroup)
                   if (!botAdmin) return client2.reply(from, logging.botIsNotAdmin)
                   if (!admin) return client2.reply(from, logging.userIsNotAdmin)

                   client2.setGroupToAdminsOnly(from, true)
                   break
               default:
                   break
            }
            break
        case 'bc':
            var encmedia = isQuotedImage ? JSON.parse(JSON.stringify(m).replace('quotedM','m')).message.extendedTextMessage.contextInfo : m
            var buffer = await client.downloadMediaMessage(encmedia)
            if (id === owner) {
                  var chat = await client.chats.all()
                  var ids = []
                  var index = 1
                  chat.map(({ jid }) => {
                      ids.push(jid)
                  })
                  var loop = (i) => {
                      if (ids[i]) {
                           client.sendMessage(ids[i], buffer, image, { caption: args.join(' '), quoted: m })
                           setTimeout(() => {
                                loop(i + 1)
                           }, 4000)
                      }
                  }
                  loop(0)
                  await client2.sendText(from, `sukses custom broadcast ke *${chat.length}* chat! ( with random delay )`)
              } else {
                  client2.reply(from, logging.isNotOwner)
              }
            break
        case 'block':
            switch (args[0]) {
                case 'add':
                    if (id === owner) {
                        var what = args.join(' ').startsWith('0') ? a.replace(/08/, 628) : args.join(' ')

                        await client.blockUser(what + '@c.us', 'add')
                        client2.reply(from, 'nomor berhasil bot block: ${what}')
                    } else {
                        client2.reply(from, logging.isNotOwner)
                    }
                    break
                case 'remove':
                    if (id === owner) {
                        var what = args.join(' ').startsWith('0') ? a.replace(/08/, 628) : args.join(' ')

                        await client.blockUser(what + '@c.us', 'remove')
                        client2.reply(from, 'nomor berhasil bot un-block: ${what}')
                    } else {
                        client2.reply(from, logging.isNotOwner)
                    }
                    break
                case 'addTag':
                    if (id === owner) {
                        var what = isGroup ? m.message.extendedTextMessage.contextInfo.mentionedJid[0] : null

                        await client.blockUser(what + '@c.us', 'add')
                        client2.reply(from, 'nomor berhasil bot block: ${what.}')
                    } else {
                        client2.reply(from, logging.isNotOwner)
                    }
                    break
                case 'removeTag':
                    if (id === owner) {
                        var what = isGroup ? m.message.extendedTextMessage.contextInfo.mentionedJid[0] : null

                        await client.blockUser(what + '@c.us', 'remove')
                        client2.reply(from, 'nomor berhasil bot un-block: ${what}')
                    } else {
                        client2.reply(from, logging.isNotOwner)
                    }
                    break
/*                case 'list':
                    var msg = `List block number length: ${block.length}\n\n`
                    var index = 1
                    block.map(data => {
                        msg += `*${index++}*. ${data.split(/@/)[0]}\n`
                    })
                    client2.reply(from, msg + copyright)
                    break*/
                default:
                    break
            }
            break
        case 'toimg':
            if (!isQuotedSticker) return client2.reply(from, logging.isNotSticker)
            var encmedia = JSON.parse(JSON.stringify(m).replace('quotedM','m')).message.extendedTextMessage.contextInfo
            var media = await client.downloadAndSaveMediaMessage(encmedia)
            var names = 'stiker.png'

            exec(`ffmpeg -i ${media} ${names}`, (err) => {
                //fs.unlinkSync(media)
                if (err) return client2.reply(from, 'error')
                client2.sendImage(from, names, 'nih')
//                var buffer = fs.readFileSync(names, 'base64')
                //client.sendMessage(from, buffer, image, {quoted: m, caption: 'nih'})
                //fs.unlinkSync(names)
            })
            break
        case 'readall':
            var result = await client.chats.all()
            if (id === owner) {
                result.map( async ({ jid }) => {
                    await client.chatRead(jid)
                })
                await client.sendMessage(from, `mengbaca semua pesan: ${result.length} pesan.`, MessageType.text, { quoted: m })
            } else {
                await client.sendMessage(from, 'kamu bukan owner!', MessageType.text, { quoted: m })
            }
            break
/*        case 'lapor':
            var nama = typeof client.chats.get(m.participant).name != 'undefined' ? client.chats.get(m.participant).name : 'private users.'
            client.sendMessage(id, 'laporan berhasil dikirim!', MessageType.text, { quoted: m })
            client.sendMessage(owner, `Laporan dari: *${nama}*\n\nID: ${m.participant.split('@')[0]}\n\n_${value}_`, MessageType.text)
            break*/
        case 'cek':
           if (!isGroup) return client2.reply(from, 'only group')
           var botAdmin = await isBotAdmin(nomorbot, from)
           client2.reply(from, `bot is admin: ${botAdmin}`)
            //client2.reply(from, nomorbot)
/*            var split = value.replace(/@|\d/gi, '').split('|')
            var taged = m.message.extendedTextMessage.contextInfo.mentionedJid[0]
            var options = {
                text: split[1],
                contextInfo: { quotedMessage: { conversation: split[0] }, participant: taged  }
                //quoted: m
            }*/
            console.log('anjayassssssssssss' + nomorbot)
//            await client.sendMessage(id, options, MessageType.text)
            break
        case 'hidetag':
            var bot = id === owner
            var admin = await isAdmin(id, from)
            if (admin || bot) {
                var group  = await client.groupMetadata(from)
                var member = group['participants']
                var admin = member.filter(admin => admin.isAdmin === true)
                var ids = []
                var index = 1
                member.map( async adm => {
                    ids.push(adm.id.replace('c.us', 's.whatsapp.net'))
                })
                var options = {
                    text: args.join(' '),
                    contextInfo: { mentionedJid: ids },
                    quoted: m
                }
                await client.sendMessage(from, options, MessageType.text)
            } else {
                client.sendMessage(from, 'kamu bukan admin!', MessageType.text, { quoted: m })
            }
            break
/*        case 'sticker':
           var image = await client.downloadAndSaveMediaMessage(m)
           exec('cwebp -q 50 ' + image + ' -o temp/' + time + '.webp', (error, stdout, stderr) => {
               let result = fs.readFileSync('temp/' + time + '.webp')
               client.sendMessage(id, result, MessageType.sticker)
           })
           break
        case 'delchatAll':
            var group  = await client.groupMetadata(id)
            var member = group['participants']
            var number = nomor.includes('s.whatsapp.net') ? nomor.replace(/s.whatsapp.net/, 'c.us') : nomor
            var isAdmin = member.filter(admin => admin.id === number)[0].isAdmin
            if (!isAdmin) {
                client.sendMessage(id, { text: `@${nomor.split("@s.whatsapp.net")[0]} kamu bukan admin!`, contextInfo: {mentionedJid: [nomor]} }, MessageType.text)
            } else {
                var result = await client.chats.all()
                client.sendMessage(id, `total pesan yang akan di hapus: *${result.length}*`, MessageType.text, { quoted: m })
                for (const i in result) {
                    let { jid, name } = i
                    client.sendMessage(id, `sedang menghapus pesan *${name}* ...`, MessageType.text)
                    var k = await client.deleteChat(jid)
                    console.log(k)
                }
            }
            break
        case 'kick':
            var group  = await client.groupMetadata(id)
            var member = group['participants']
            var number = nomor.includes('s.whatsapp.net') ? nomor.replace(/s.whatsapp.net/, 'c.us') : nomor
            var isAdmin = member.filter(admin => admin.id === number)[0].isAdmin
            if (!isAdmin) {
                client.sendMessage(id, { text: `@${nomor.split("@s.whatsapp.net")[0]} kamu bukan admin!`, contextInfo: {mentionedJid: [nomor]} }, MessageType.text)
            } else {
                var result = await client.groupRemove(id, [messageContent.extendedTextMessage.contextInfo.mentionedJid[0].replace(/s.whatsapp.net/, 'c.us')])
                client.sendMessage(id, JSON.stringify(result), MessageType.text, { quoted: m })
                console.log(result)
            }
            break
        case 'bc': {
                    if (nomor === owner) {
                        var chat = await client.chats.all()
                        var ids = []
                        var index = 0
                        chat.map(({ jid }) => {
                            ids.push(jid)
                        })
                        var loop = (i) => {
                            if (ids[i]) {
                                client.sendMessage(ids[i], value, MessageType.text)
                                setTimeout(() => {
                                    loop(i + 1)
                                }, 4000)
                            }
                        }
                        loop(0)
                        await client.sendMessage(id, `sukses custom broadcast ke *${chat.length}* chat! ( with random delay )`, MessageType.text, { quoted: m })
                    } else {
                        client.sendMessage(id, 'command khusus owner!', MessageType.text, { quoted: m })
                    }
                }
                    break*/
/*        case 'debug':
            switch (value) {
                case 'lapor':
                    var dt = client.chats.get(m.participant)
                    console.log(dt)
                    break
                case 'admin':
                    var w = await isAdmin(nomor, id)
                    client.sendMessage(id, `is admin: ${w}`, MessageType.text, { quoted: m })
                    break
                case 'getchat':
                    var chat = await client.chats.all()
                    console.log(chat)
                    var index = 1
                    var msg = `Jumlah pesan aex-bot: *${chat.length}* chat\n\n`
                    chat.map(({ name, count }) => {
                        msg += `*${index++}*. \`\`\`${name}\`\`\` ( *${count}* chat )\n`
                    })
                    client.sendMessage(id, msg, MessageType.text, { quoted: m })
                    break
                case 'system':
                    var data = spawnSync('neofetch', ['--stdout']).stdout.toString('utf-8')
                    client.sendMessage(id, `\`\`\`${data.replace('u0_a158', 'syawal')}\`\`\`${copyright}`, MessageType.text, { quoted: m })
                    break
/*                case 'bc': {
                    if (nomor === owner) {
                        var chat = await client.chats.all()
                        var ids = []
                        var index = 0
                        chat.map(({ jid }) => {
                            ids.push(jid)
                        })
                        var loop = (i) => {
                            if (ids[i]) {
                                client.sendMessage(ids[i], value2, MessageType.text)
                                setTimeout(() => {
                                    loop(i + 1)
                                }, 4000)
                            }
                        }
                        loop(0)
                        await client.sendMessage(id, `sukses custom broadcast ke *${chat.length}* chat! ( with random delay )`, MessageType.text, { quoted: m })
                    } else {
                        client.sendMessage(id, 'command khusus owner!', MessageType.text, { quoted: m })
                    }
                }
                    break // 
                default:
                    var decomand = ['lapor', 'getchat', 'system']
                    var index = 1
                    var msg = `men-debug command aex, debuging harus disertakan argumen valid:\n\n`
                    decomand.map(cmd => {
                        msg += `.debug *${cmd}*\n`
                    })
                    client.sendMessage(id, `${msg}${copyright}`, MessageType.text, { quoted: m })
                    break
            }
            break
        case 'coba':
            if (nomor === owner) client.sendMessage(id, { text: `@${nomor.split("@s.whatsapp.net")[0]} sip kamu owner! hh`, contextInfo: {mentionedJid: [nomor]}, quoted: m }, MessageType.text)
            else client.sendMessage(id, { text: `@${nomor.split("@s.whatsapp.net")[0]} kamu bukan owner bot!`, contextInfo: {mentionedJid: [nomor]}, quoted: m }, MessageType.text)
            break
        case 'tagall':
            var group  = await client.groupMetadata(id)
            var member = group['participants']
            var ids = []
            var msg = `\`\`\`TAG ALL NIH\`\`\` ( *${member.length}* orang. )\n\n`
            var index = 1
            member.map( async (uye) => {
                msg += `${index++}. @${uye.id.split('@')[0]}\n`
                ids.push(uye.id.replace('c.us', 's.whatsapp.net'))
            })
            console.log(JSON.stringify(group, null, '\t'))
            const _options = {
                text: msg,
                contextInfo: { mentionedJid: ids }
            }
            await client.sendMessage(id, _options, MessageType.text)
            break
/*        case 'adlhsy':
            var group  = await client.groupMetadata(id)
            var member = group['participants']
            var number = nomor.includes('s.whatsapp.net') ? nomor.replace(/s.whatsapp.net/, 'c.us') : nomor
            var isAdmin = member.filter(admin => admin.id === number)[0].isAdmin
/*            const options = {
                text: `@${nomor.split("@s.whatsapp.net")[0]} tagged!`,
                contextInfo: { mentionedJid: [nomor] }
            } // 
            if (!isAdmin) client.sendMessage(id, { text: `@${nomor.split("@s.whatsapp.net")[0]} kamu bukan admin!`, contextInfo: {mentionedJid: [nomor]} }, MessageType.text)
            else client.sendMessage(id, 'ok', MessageType.text)
            break
        case 'spadmin':
            var group  = await client.groupMetadata(id)
            var member = group['participants']
            var admin = member.filter(admin => admin.isAdmin === true)
            var ids = []
            var msg = `\`\`\`ADMIN GC ${group.subject}\`\`\` ( *${admin.length}* orang. )\n\n`
            var index = 1
            admin.map( async adm => {
                msg += `${index++}. @${adm.id.split('@')[0]}\n`
                ids.push(adm.id.replace('c.us', 's.whatsapp.net'))
            })
            var options = {
                text: msg,
                contextInfo: { mentionedJid: ids },
                quoted: m
            }
            await client.sendMessage(id, options, MessageType.text)
            break
        case 'owner':
            var group  = await client.groupMetadata(id)
            var member = group['participants']
            var owner = group['owner']
            var ids = [owner.replace('c.us', 's.whatsapp.net')]
            var msg = `owner group *${group.subject}* adalah: @${owner.split('@')[0]}`
            var options = {
                text: msg,
                contextInfo: { mentionedJid: ids },
                quoted: m
            }
            await client.sendMessage(id, options, MessageType.text)
            break
        case 'tagme':
            var options = {
                text: `@${nomor.split("@s.whatsapp.net")[0]} tagged!`,
                contextInfo: { mentionedJid: [nomor] }
            }
            client.sendMessage(id, options, MessageType.text)
            break
        case 'porn':
            textPorn(value)
                .then(data => {
                    const { result: porn } = data
                    imageToBase64(porn)
                       .then(_data => {
                           var buffer = Buffer.from(_data, 'base64')
                           client.sendMessage(id, buffer, MessageType.image, { quoted: m, caption: value })
                    })
                })
                .catch(err => {
                    console.log(err)
                })
            break
        case 'test':
            let i = 1
            const json = {
                text: 'mengirim text dengan format json.',
                id: i++
            }
            //client.sendJSON()
            break
        case 'tree':
            Archy()
               .then(data => {
                   var data = `*s* T r U k t U R c 0 d s\n\n${data}${copyright}`
                   client.sendMessage(id, data, MessageType.text, { quoted: m })
               })
            break
        case 'tourl':
            var image = await client.downloadAndSaveMediaMessage(m)
            client.sendMessage(id, '\`\`\`sedang mengconvert.. .\`\`\`', MessageType.text, { quoted: m })
            var data = fs.readFileSync('./' + image, 'base64')
            imgBB(data)
              .then(uri => {
                  imageToBase64(uri)
                     .then(_data => {
                          var buffer = Buffer.from(_data, 'base64')
                          client.sendMessage(id, buffer, MessageType.image, { quoted: m, caption: `success convert to url!!\n\n*${uri}*${copyright}`})
                      })
              })
            break*/
/*        case 'random':
            break
        case 'random':
            break
        case 'random':
            break
        case 'random':
            break
        case 'random':
            break
        case 'random':
            break
        case 'random':
            break*/
        default:
            break
    }
}

module.exports = CUSTOMHANDLER
